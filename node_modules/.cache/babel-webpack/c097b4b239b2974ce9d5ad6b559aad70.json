{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/mac/WebstormProjects/github-page/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _toConsumableArray from \"/Users/mac/WebstormProjects/github-page/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/mac/WebstormProjects/github-page/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/mac/WebstormProjects/github-page/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Injectable, InjectionToken } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport * as Éµngcc0 from '@angular/core';\n\nvar NzTreeNode = /*#__PURE__*/function () {\n  /**\n   * Init nzTreeNode\n   * @param option: user's input\n   * @param parent\n   * @param service: base nzTreeService\n   */\n  function NzTreeNode(option) {\n    var _this = this;\n\n    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var service = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    _classCallCheck(this, NzTreeNode);\n\n    this._title = '';\n    this.level = 0; // Parent Node\n\n    this.parentNode = null;\n    this._icon = '';\n    this._children = [];\n    this._isLeaf = false;\n    this._isChecked = false;\n    this._isSelectable = false;\n    this._isDisabled = false;\n    this._isDisableCheckbox = false;\n    this._isExpanded = false;\n    this._isHalfChecked = false;\n    this._isSelected = false;\n    this._isLoading = false;\n    this.canHide = false;\n    this.isMatched = false;\n    this.service = null;\n\n    if (option instanceof NzTreeNode) {\n      return option;\n    }\n\n    this.service = service || null;\n    this.origin = option;\n    this.key = option.key;\n    this.parentNode = parent;\n    this._title = option.title || '---';\n    this._icon = option.icon || '';\n    this._isLeaf = option.isLeaf || false;\n    this._children = []; // option params\n\n    this._isChecked = option.checked || false;\n    this._isSelectable = option.disabled || option.selectable !== false;\n    this._isDisabled = option.disabled || false;\n    this._isDisableCheckbox = option.disableCheckbox || false;\n    this._isExpanded = option.isLeaf ? false : option.expanded || false;\n    this._isHalfChecked = false;\n    this._isSelected = !option.disabled && option.selected || false;\n    this._isLoading = false;\n    this.isMatched = false;\n    /**\n     * parent's checked status will affect children while initializing\n     */\n\n    if (parent) {\n      this.level = parent.level + 1;\n    } else {\n      this.level = 0;\n    }\n\n    if (typeof option.children !== 'undefined' && option.children !== null) {\n      option.children.forEach(function (nodeOptions) {\n        var s = _this.treeService;\n\n        if (s && !s.isCheckStrictly && option.checked && !option.disabled && !nodeOptions.disabled && !nodeOptions.disableCheckbox) {\n          nodeOptions.checked = option.checked;\n        }\n\n        _this._children.push(new NzTreeNode(nodeOptions, _this));\n      });\n    }\n  }\n\n  _createClass(NzTreeNode, [{\n    key: \"treeService\",\n    get: function get() {\n      return this.service || this.parentNode && this.parentNode.treeService;\n    }\n    /**\n     * auto generate\n     * get\n     * set\n     */\n\n  }, {\n    key: \"title\",\n    get: function get() {\n      return this._title;\n    },\n    set: function set(value) {\n      this._title = value;\n      this.update();\n    }\n  }, {\n    key: \"icon\",\n    get: function get() {\n      return this._icon;\n    },\n    set: function set(value) {\n      this._icon = value;\n      this.update();\n    }\n  }, {\n    key: \"children\",\n    get: function get() {\n      return this._children;\n    },\n    set: function set(value) {\n      this._children = value;\n      this.update();\n    }\n  }, {\n    key: \"isLeaf\",\n    get: function get() {\n      return this._isLeaf;\n    },\n    set: function set(value) {\n      this._isLeaf = value;\n      this.update();\n    }\n  }, {\n    key: \"isChecked\",\n    get: function get() {\n      return this._isChecked;\n    },\n    set: function set(value) {\n      this._isChecked = value;\n      this.origin.checked = value;\n      this.afterValueChange('isChecked');\n    }\n  }, {\n    key: \"isHalfChecked\",\n    get: function get() {\n      return this._isHalfChecked;\n    },\n    set: function set(value) {\n      this._isHalfChecked = value;\n      this.afterValueChange('isHalfChecked');\n    }\n  }, {\n    key: \"isSelectable\",\n    get: function get() {\n      return this._isSelectable;\n    },\n    set: function set(value) {\n      this._isSelectable = value;\n      this.update();\n    }\n  }, {\n    key: \"isDisabled\",\n    get: function get() {\n      return this._isDisabled;\n    },\n    set: function set(value) {\n      this._isDisabled = value;\n      this.update();\n    }\n  }, {\n    key: \"isDisableCheckbox\",\n    get: function get() {\n      return this._isDisableCheckbox;\n    },\n    set: function set(value) {\n      this._isDisableCheckbox = value;\n      this.update();\n    }\n  }, {\n    key: \"isExpanded\",\n    get: function get() {\n      return this._isExpanded;\n    },\n    set: function set(value) {\n      this._isExpanded = value;\n      this.origin.expanded = value;\n      this.afterValueChange('isExpanded');\n      this.afterValueChange('reRender');\n    }\n  }, {\n    key: \"isSelected\",\n    get: function get() {\n      return this._isSelected;\n    },\n    set: function set(value) {\n      this._isSelected = value;\n      this.origin.selected = value;\n      this.afterValueChange('isSelected');\n    }\n  }, {\n    key: \"isLoading\",\n    get: function get() {\n      return this._isLoading;\n    },\n    set: function set(value) {\n      this._isLoading = value;\n      this.update();\n    }\n  }, {\n    key: \"setSyncChecked\",\n    value: function setSyncChecked() {\n      var checked = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var halfChecked = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this.setChecked(checked, halfChecked);\n\n      if (this.treeService && !this.treeService.isCheckStrictly) {\n        this.treeService.conduct(this);\n      }\n    }\n  }, {\n    key: \"setChecked\",\n    value: function setChecked() {\n      var checked = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var halfChecked = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this.origin.checked = checked;\n      this.isChecked = checked;\n      this.isHalfChecked = halfChecked;\n    }\n  }, {\n    key: \"setExpanded\",\n    value: function setExpanded(value) {\n      this._isExpanded = value;\n      this.origin.expanded = value;\n      this.afterValueChange('isExpanded');\n    }\n  }, {\n    key: \"getParentNode\",\n    value: function getParentNode() {\n      return this.parentNode;\n    }\n  }, {\n    key: \"getChildren\",\n    value: function getChildren() {\n      return this.children;\n    }\n    /**\n     * Support appending child nodes by position. Leaf node cannot be appended.\n     */\n\n  }, {\n    key: \"addChildren\",\n    value: function addChildren(children) {\n      var _this2 = this;\n\n      var childPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n\n      if (!this.isLeaf) {\n        children.forEach(function (node) {\n          var refreshLevel = function refreshLevel(n) {\n            n.getChildren().forEach(function (c) {\n              c.level = c.getParentNode().level + 1; // flush origin\n\n              c.origin.level = c.level;\n              refreshLevel(c);\n            });\n          };\n\n          var child = node;\n\n          if (child instanceof NzTreeNode) {\n            child.parentNode = _this2;\n          } else {\n            child = new NzTreeNode(node, _this2);\n          }\n\n          child.level = _this2.level + 1;\n          child.origin.level = child.level;\n          refreshLevel(child);\n\n          try {\n            childPos === -1 ? _this2.children.push(child) : _this2.children.splice(childPos, 0, child); // flush origin\n          } catch (e) {}\n        });\n        this.origin.children = this.getChildren().map(function (v) {\n          return v.origin;\n        }); // remove loading state\n\n        this.isLoading = false;\n      }\n\n      this.afterValueChange('addChildren');\n      this.afterValueChange('reRender');\n    }\n  }, {\n    key: \"clearChildren\",\n    value: function clearChildren() {\n      // refresh checked state\n      this.afterValueChange('clearChildren');\n      this.children = [];\n      this.origin.children = [];\n      this.afterValueChange('reRender');\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var _this3 = this;\n\n      var parentNode = this.getParentNode();\n\n      if (parentNode) {\n        parentNode.children = parentNode.getChildren().filter(function (v) {\n          return v.key !== _this3.key;\n        });\n        parentNode.origin.children = parentNode.origin.children.filter(function (v) {\n          return v.key !== _this3.key;\n        });\n        this.afterValueChange('remove');\n        this.afterValueChange('reRender');\n      }\n    }\n  }, {\n    key: \"afterValueChange\",\n    value: function afterValueChange(key) {\n      if (this.treeService) {\n        switch (key) {\n          case 'isChecked':\n            this.treeService.setCheckedNodeList(this);\n            break;\n\n          case 'isHalfChecked':\n            this.treeService.setHalfCheckedNodeList(this);\n            break;\n\n          case 'isExpanded':\n            this.treeService.setExpandedNodeList(this);\n            break;\n\n          case 'isSelected':\n            this.treeService.setNodeActive(this);\n            break;\n\n          case 'clearChildren':\n            this.treeService.afterRemove(this.getChildren());\n            break;\n\n          case 'remove':\n            this.treeService.afterRemove([this]);\n            break;\n\n          case 'reRender':\n            this.treeService.flattenTreeData(this.treeService.rootNodes, this.treeService.getExpandedNodeList().map(function (v) {\n              return v.key;\n            }));\n            break;\n        }\n      }\n\n      this.update();\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (this.component) {\n        this.component.markForCheck();\n      }\n    }\n  }]);\n\n  return NzTreeNode;\n}();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nfunction isCheckDisabled(node) {\n  var isDisabled = node.isDisabled,\n      isDisableCheckbox = node.isDisableCheckbox;\n  return !!(isDisabled || isDisableCheckbox);\n}\n\nfunction isInArray(needle, haystack) {\n  return haystack.length > 0 && haystack.indexOf(needle) > -1;\n}\n\nfunction getPosition(level, index) {\n  return \"\".concat(level, \"-\").concat(index);\n}\n\nfunction getKey(key, pos) {\n  if (key !== null && key !== undefined) {\n    return key;\n  }\n\n  return pos;\n}\n/**\n * Flat nest tree data into flatten list. This is used for virtual list render.\n * @param treeNodeList Origin data node list\n * @param expandedKeys\n * need expanded keys, provides `true` means all expanded (used in `rc-tree-select`).\n */\n\n\nfunction _flattenTreeData() {\n  var treeNodeList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var expandedKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var expandedKeySet = new Set(expandedKeys === true ? [] : expandedKeys);\n  var flattenList = [];\n\n  function dig(list) {\n    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return list.map(function (treeNode, index) {\n      var pos = getPosition(parent ? parent.pos : '0', index);\n      var mergedKey = getKey(treeNode.key, pos);\n      treeNode.isStart = [].concat(_toConsumableArray(parent ? parent.isStart : []), [index === 0]);\n      treeNode.isEnd = [].concat(_toConsumableArray(parent ? parent.isEnd : []), [index === list.length - 1]); // Add FlattenDataNode into list\n      // TODO: only need data here.\n\n      var flattenNode = {\n        parent: parent,\n        pos: pos,\n        children: [],\n        data: treeNode,\n        isStart: [].concat(_toConsumableArray(parent ? parent.isStart : []), [index === 0]),\n        isEnd: [].concat(_toConsumableArray(parent ? parent.isEnd : []), [index === list.length - 1])\n      };\n      flattenList.push(flattenNode); // Loop treeNode children\n\n      if (expandedKeys === true || expandedKeySet.has(mergedKey) || treeNode.isExpanded) {\n        flattenNode.children = dig(treeNode.children || [], flattenNode);\n      } else {\n        flattenNode.children = [];\n      }\n\n      return flattenNode;\n    });\n  }\n\n  dig(treeNodeList);\n  return flattenList;\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nvar NzTreeBaseService = /*#__PURE__*/function () {\n  function NzTreeBaseService() {\n    _classCallCheck(this, NzTreeBaseService);\n\n    this.DRAG_SIDE_RANGE = 0.25;\n    this.DRAG_MIN_GAP = 2;\n    this.isCheckStrictly = false;\n    this.isMultiple = false;\n    this.rootNodes = [];\n    this.flattenNodes$ = new BehaviorSubject([]);\n    this.selectedNodeList = [];\n    this.expandedNodeList = [];\n    this.checkedNodeList = [];\n    this.halfCheckedNodeList = [];\n    this.matchedNodeList = [];\n  }\n  /**\n   * reset tree nodes will clear default node list\n   */\n\n\n  _createClass(NzTreeBaseService, [{\n    key: \"initTree\",\n    value: function initTree(nzNodes) {\n      this.rootNodes = nzNodes;\n      this.expandedNodeList = [];\n      this.selectedNodeList = [];\n      this.halfCheckedNodeList = [];\n      this.checkedNodeList = [];\n      this.matchedNodeList = [];\n    }\n  }, {\n    key: \"flattenTreeData\",\n    value: function flattenTreeData(nzNodes) {\n      var expandedKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      this.flattenNodes$.next(_flattenTreeData(nzNodes, expandedKeys).map(function (item) {\n        return item.data;\n      }));\n    }\n  }, {\n    key: \"getSelectedNode\",\n    value: function getSelectedNode() {\n      return this.selectedNode;\n    }\n    /**\n     * get some list\n     */\n\n  }, {\n    key: \"getSelectedNodeList\",\n    value: function getSelectedNodeList() {\n      return this.conductNodeState('select');\n    }\n    /**\n     * return checked nodes\n     */\n\n  }, {\n    key: \"getCheckedNodeList\",\n    value: function getCheckedNodeList() {\n      return this.conductNodeState('check');\n    }\n  }, {\n    key: \"getHalfCheckedNodeList\",\n    value: function getHalfCheckedNodeList() {\n      return this.conductNodeState('halfCheck');\n    }\n    /**\n     * return expanded nodes\n     */\n\n  }, {\n    key: \"getExpandedNodeList\",\n    value: function getExpandedNodeList() {\n      return this.conductNodeState('expand');\n    }\n    /**\n     * return search matched nodes\n     */\n\n  }, {\n    key: \"getMatchedNodeList\",\n    value: function getMatchedNodeList() {\n      return this.conductNodeState('match');\n    }\n  }, {\n    key: \"isArrayOfNzTreeNode\",\n    value: function isArrayOfNzTreeNode(value) {\n      return value.every(function (item) {\n        return item instanceof NzTreeNode;\n      });\n    }\n    /**\n     * set drag node\n     */\n\n  }, {\n    key: \"setSelectedNode\",\n    value: function setSelectedNode(node) {\n      this.selectedNode = node;\n    }\n    /**\n     * set node selected status\n     */\n\n  }, {\n    key: \"setNodeActive\",\n    value: function setNodeActive(node) {\n      if (!this.isMultiple && node.isSelected) {\n        this.selectedNodeList.forEach(function (n) {\n          if (node.key !== n.key) {\n            // reset other nodes\n            n.isSelected = false;\n          }\n        }); // single mode: remove pre node\n\n        this.selectedNodeList = [];\n      }\n\n      this.setSelectedNodeList(node, this.isMultiple);\n    }\n    /**\n     * add or remove node to selectedNodeList\n     */\n\n  }, {\n    key: \"setSelectedNodeList\",\n    value: function setSelectedNodeList(node) {\n      var isMultiple = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var index = this.getIndexOfArray(this.selectedNodeList, node.key);\n\n      if (isMultiple) {\n        if (node.isSelected && index === -1) {\n          this.selectedNodeList.push(node);\n        }\n      } else {\n        if (node.isSelected && index === -1) {\n          this.selectedNodeList = [node];\n        }\n      }\n\n      if (!node.isSelected) {\n        this.selectedNodeList = this.selectedNodeList.filter(function (n) {\n          return n.key !== node.key;\n        });\n      }\n    }\n    /**\n     * merge checked nodes\n     */\n\n  }, {\n    key: \"setHalfCheckedNodeList\",\n    value: function setHalfCheckedNodeList(node) {\n      var index = this.getIndexOfArray(this.halfCheckedNodeList, node.key);\n\n      if (node.isHalfChecked && index === -1) {\n        this.halfCheckedNodeList.push(node);\n      } else if (!node.isHalfChecked && index > -1) {\n        this.halfCheckedNodeList = this.halfCheckedNodeList.filter(function (n) {\n          return node.key !== n.key;\n        });\n      }\n    }\n  }, {\n    key: \"setCheckedNodeList\",\n    value: function setCheckedNodeList(node) {\n      var index = this.getIndexOfArray(this.checkedNodeList, node.key);\n\n      if (node.isChecked && index === -1) {\n        this.checkedNodeList.push(node);\n      } else if (!node.isChecked && index > -1) {\n        this.checkedNodeList = this.checkedNodeList.filter(function (n) {\n          return node.key !== n.key;\n        });\n      }\n    }\n    /**\n     * conduct checked/selected/expanded keys\n     */\n\n  }, {\n    key: \"conductNodeState\",\n    value: function conductNodeState() {\n      var _this4 = this;\n\n      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'check';\n      var resultNodesList = [];\n\n      switch (type) {\n        case 'select':\n          resultNodesList = this.selectedNodeList;\n          break;\n\n        case 'expand':\n          resultNodesList = this.expandedNodeList;\n          break;\n\n        case 'match':\n          resultNodesList = this.matchedNodeList;\n          break;\n\n        case 'check':\n          resultNodesList = this.checkedNodeList;\n\n          var isIgnore = function isIgnore(node) {\n            var parentNode = node.getParentNode();\n\n            if (parentNode) {\n              if (_this4.checkedNodeList.findIndex(function (n) {\n                return n.key === parentNode.key;\n              }) > -1) {\n                return true;\n              } else {\n                return isIgnore(parentNode);\n              }\n            }\n\n            return false;\n          }; // merge checked\n\n\n          if (!this.isCheckStrictly) {\n            resultNodesList = this.checkedNodeList.filter(function (n) {\n              return !isIgnore(n);\n            });\n          }\n\n          break;\n\n        case 'halfCheck':\n          if (!this.isCheckStrictly) {\n            resultNodesList = this.halfCheckedNodeList;\n          }\n\n          break;\n      }\n\n      return resultNodesList;\n    }\n    /**\n     * set expanded nodes\n     */\n\n  }, {\n    key: \"setExpandedNodeList\",\n    value: function setExpandedNodeList(node) {\n      if (node.isLeaf) {\n        return;\n      }\n\n      var index = this.getIndexOfArray(this.expandedNodeList, node.key);\n\n      if (node.isExpanded && index === -1) {\n        this.expandedNodeList.push(node);\n      } else if (!node.isExpanded && index > -1) {\n        this.expandedNodeList.splice(index, 1);\n      }\n    }\n  }, {\n    key: \"setMatchedNodeList\",\n    value: function setMatchedNodeList(node) {\n      var index = this.getIndexOfArray(this.matchedNodeList, node.key);\n\n      if (node.isMatched && index === -1) {\n        this.matchedNodeList.push(node);\n      } else if (!node.isMatched && index > -1) {\n        this.matchedNodeList.splice(index, 1);\n      }\n    }\n    /**\n     * check state\n     * @param isCheckStrictly\n     */\n\n  }, {\n    key: \"refreshCheckState\",\n    value: function refreshCheckState() {\n      var _this5 = this;\n\n      var isCheckStrictly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (isCheckStrictly) {\n        return;\n      }\n\n      this.checkedNodeList.forEach(function (node) {\n        _this5.conduct(node, isCheckStrictly);\n      });\n    } // reset other node checked state based current node\n\n  }, {\n    key: \"conduct\",\n    value: function conduct(node) {\n      var isCheckStrictly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var isChecked = node.isChecked;\n\n      if (node && !isCheckStrictly) {\n        this.conductUp(node);\n        this.conductDown(node, isChecked);\n      }\n    }\n    /**\n     * 1ãchildren half checked\n     * 2ãchildren all checked, parent checked\n     * 3ãno children checked\n     */\n\n  }, {\n    key: \"conductUp\",\n    value: function conductUp(node) {\n      var parentNode = node.getParentNode();\n\n      if (parentNode) {\n        if (!isCheckDisabled(parentNode)) {\n          if (parentNode.children.every(function (child) {\n            return isCheckDisabled(child) || !child.isHalfChecked && child.isChecked;\n          })) {\n            parentNode.isChecked = true;\n            parentNode.isHalfChecked = false;\n          } else if (parentNode.children.some(function (child) {\n            return child.isHalfChecked || child.isChecked;\n          })) {\n            parentNode.isChecked = false;\n            parentNode.isHalfChecked = true;\n          } else {\n            parentNode.isChecked = false;\n            parentNode.isHalfChecked = false;\n          }\n        }\n\n        this.setCheckedNodeList(parentNode);\n        this.setHalfCheckedNodeList(parentNode);\n        this.conductUp(parentNode);\n      }\n    }\n    /**\n     * reset child check state\n     */\n\n  }, {\n    key: \"conductDown\",\n    value: function conductDown(node, value) {\n      var _this6 = this;\n\n      if (!isCheckDisabled(node)) {\n        node.isChecked = value;\n        node.isHalfChecked = false;\n        this.setCheckedNodeList(node);\n        this.setHalfCheckedNodeList(node);\n        node.children.forEach(function (n) {\n          _this6.conductDown(n, value);\n        });\n      }\n    }\n    /**\n     * flush after delete node\n     */\n\n  }, {\n    key: \"afterRemove\",\n    value: function afterRemove(nodes) {\n      var _this7 = this;\n\n      // to reset selectedNodeList & expandedNodeList\n      var loopNode = function loopNode(node) {\n        // remove selected node\n        _this7.selectedNodeList = _this7.selectedNodeList.filter(function (n) {\n          return n.key !== node.key;\n        }); // remove expanded node\n\n        _this7.expandedNodeList = _this7.expandedNodeList.filter(function (n) {\n          return n.key !== node.key;\n        }); // remove checked node\n\n        _this7.checkedNodeList = _this7.checkedNodeList.filter(function (n) {\n          return n.key !== node.key;\n        });\n\n        if (node.children) {\n          node.children.forEach(function (child) {\n            loopNode(child);\n          });\n        }\n      };\n\n      nodes.forEach(function (n) {\n        loopNode(n);\n      });\n      this.refreshCheckState(this.isCheckStrictly);\n    }\n    /**\n     * drag event\n     */\n\n  }, {\n    key: \"refreshDragNode\",\n    value: function refreshDragNode(node) {\n      var _this8 = this;\n\n      if (node.children.length === 0) {\n        // until root\n        this.conductUp(node);\n      } else {\n        node.children.forEach(function (child) {\n          _this8.refreshDragNode(child);\n        });\n      }\n    } // reset node level\n\n  }, {\n    key: \"resetNodeLevel\",\n    value: function resetNodeLevel(node) {\n      var parentNode = node.getParentNode();\n\n      if (parentNode) {\n        node.level = parentNode.level + 1;\n      } else {\n        node.level = 0;\n      }\n\n      var _iterator = _createForOfIteratorHelper(node.children),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var child = _step.value;\n          this.resetNodeLevel(child);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"calcDropPosition\",\n    value: function calcDropPosition(event) {\n      var clientY = event.clientY; // to fix firefox undefined\n\n      var _event$target$getBoun = event.target.getBoundingClientRect(),\n          top = _event$target$getBoun.top,\n          bottom = _event$target$getBoun.bottom,\n          height = _event$target$getBoun.height;\n\n      var des = Math.max(height * this.DRAG_SIDE_RANGE, this.DRAG_MIN_GAP);\n\n      if (clientY <= top + des) {\n        return -1;\n      } else if (clientY >= bottom - des) {\n        return 1;\n      }\n\n      return 0;\n    }\n    /**\n     * drop\n     * 0: inner -1: pre 1: next\n     */\n\n  }, {\n    key: \"dropAndApply\",\n    value: function dropAndApply(targetNode) {\n      var _this9 = this;\n\n      var dragPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n\n      if (!targetNode || dragPos > 1) {\n        return;\n      }\n\n      var treeService = targetNode.treeService;\n      var targetParent = targetNode.getParentNode();\n      var isSelectedRootNode = this.selectedNode.getParentNode(); // remove the dragNode\n\n      if (isSelectedRootNode) {\n        isSelectedRootNode.children = isSelectedRootNode.children.filter(function (n) {\n          return n.key !== _this9.selectedNode.key;\n        });\n      } else {\n        this.rootNodes = this.rootNodes.filter(function (n) {\n          return n.key !== _this9.selectedNode.key;\n        });\n      }\n\n      switch (dragPos) {\n        case 0:\n          targetNode.addChildren([this.selectedNode]);\n          this.resetNodeLevel(targetNode);\n          break;\n\n        case -1:\n        case 1:\n          var tIndex = dragPos === 1 ? 1 : 0;\n\n          if (targetParent) {\n            targetParent.addChildren([this.selectedNode], targetParent.children.indexOf(targetNode) + tIndex);\n            var parentNode = this.selectedNode.getParentNode();\n\n            if (parentNode) {\n              this.resetNodeLevel(parentNode);\n            }\n          } else {\n            var targetIndex = this.rootNodes.indexOf(targetNode) + tIndex; // Insert root node.\n\n            this.rootNodes.splice(targetIndex, 0, this.selectedNode);\n            this.rootNodes[targetIndex].parentNode = null;\n            this.resetNodeLevel(this.rootNodes[targetIndex]);\n          }\n\n          break;\n      } // flush all nodes\n\n\n      this.rootNodes.forEach(function (child) {\n        if (!child.treeService) {\n          child.service = treeService;\n        }\n\n        _this9.refreshDragNode(child);\n      });\n    }\n    /**\n     * emit Structure\n     * eventName\n     * node\n     * event: MouseEvent / DragEvent\n     * dragNode\n     */\n\n  }, {\n    key: \"formatEvent\",\n    value: function formatEvent(eventName, node, event) {\n      var emitStructure = {\n        eventName: eventName,\n        node: node,\n        event: event\n      };\n\n      switch (eventName) {\n        case 'dragstart':\n        case 'dragenter':\n        case 'dragover':\n        case 'dragleave':\n        case 'drop':\n        case 'dragend':\n          Object.assign(emitStructure, {\n            dragNode: this.getSelectedNode()\n          });\n          break;\n\n        case 'click':\n        case 'dblclick':\n          Object.assign(emitStructure, {\n            selectedKeys: this.selectedNodeList\n          });\n          Object.assign(emitStructure, {\n            nodes: this.selectedNodeList\n          });\n          Object.assign(emitStructure, {\n            keys: this.selectedNodeList.map(function (n) {\n              return n.key;\n            })\n          });\n          break;\n\n        case 'check':\n          var checkedNodeList = this.getCheckedNodeList();\n          Object.assign(emitStructure, {\n            checkedKeys: checkedNodeList\n          });\n          Object.assign(emitStructure, {\n            nodes: checkedNodeList\n          });\n          Object.assign(emitStructure, {\n            keys: checkedNodeList.map(function (n) {\n              return n.key;\n            })\n          });\n          break;\n\n        case 'search':\n          Object.assign(emitStructure, {\n            matchedKeys: this.getMatchedNodeList()\n          });\n          Object.assign(emitStructure, {\n            nodes: this.getMatchedNodeList()\n          });\n          Object.assign(emitStructure, {\n            keys: this.getMatchedNodeList().map(function (n) {\n              return n.key;\n            })\n          });\n          break;\n\n        case 'expand':\n          Object.assign(emitStructure, {\n            nodes: this.expandedNodeList\n          });\n          Object.assign(emitStructure, {\n            keys: this.expandedNodeList.map(function (n) {\n              return n.key;\n            })\n          });\n          break;\n      }\n\n      return emitStructure;\n    }\n    /**\n     * New functions for flatten nodes\n     */\n\n  }, {\n    key: \"getIndexOfArray\",\n    value: function getIndexOfArray(list, key) {\n      return list.findIndex(function (v) {\n        return v.key === key;\n      });\n    }\n    /**\n     * Render by nzCheckedKeys\n     * When keys equals null, just render with checkStrictly\n     * @param keys\n     * @param checkStrictly\n     */\n\n  }, {\n    key: \"conductCheck\",\n    value: function conductCheck(keys, checkStrictly) {\n      this.checkedNodeList = [];\n      this.halfCheckedNodeList = [];\n\n      var calc = function calc(nodes) {\n        nodes.forEach(function (node) {\n          if (keys === null) {\n            // render tree if no default checked keys found\n            node.isChecked = !!node.origin.checked;\n          } else {\n            if (isInArray(node.key, keys || [])) {\n              node.isChecked = true;\n              node.isHalfChecked = false;\n            } else {\n              node.isChecked = false;\n              node.isHalfChecked = false;\n            }\n          }\n\n          if (node.children.length > 0) {\n            calc(node.children);\n          }\n        });\n      };\n\n      calc(this.rootNodes);\n      this.refreshCheckState(checkStrictly);\n    }\n  }, {\n    key: \"conductExpandedKeys\",\n    value: function conductExpandedKeys() {\n      var _this10 = this;\n\n      var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var expandedKeySet = new Set(keys === true ? [] : keys);\n      this.expandedNodeList = [];\n\n      var calc = function calc(nodes) {\n        nodes.forEach(function (node) {\n          node.setExpanded(keys === true || expandedKeySet.has(node.key) || node.isExpanded === true);\n\n          if (node.isExpanded) {\n            _this10.setExpandedNodeList(node);\n          }\n\n          if (node.children.length > 0) {\n            calc(node.children);\n          }\n        });\n      };\n\n      calc(this.rootNodes);\n    }\n  }, {\n    key: \"conductSelectedKeys\",\n    value: function conductSelectedKeys(keys, isMulti) {\n      var _this11 = this;\n\n      this.selectedNodeList.forEach(function (node) {\n        return node.isSelected = false;\n      });\n      this.selectedNodeList = [];\n\n      var calc = function calc(nodes) {\n        return nodes.every(function (node) {\n          if (isInArray(node.key, keys)) {\n            node.isSelected = true;\n\n            _this11.setSelectedNodeList(node);\n\n            if (!isMulti) {\n              // if not support multi select\n              return false;\n            }\n          } else {\n            node.isSelected = false;\n          }\n\n          if (node.children.length > 0) {\n            // Recursion\n            return calc(node.children);\n          }\n\n          return true;\n        });\n      };\n\n      calc(this.rootNodes);\n    }\n    /**\n     * Expand parent nodes by child node\n     * @param node\n     */\n\n  }, {\n    key: \"expandNodeAllParentBySearch\",\n    value: function expandNodeAllParentBySearch(node) {\n      var _this12 = this;\n\n      var calc = function calc(n) {\n        if (n) {\n          n.canHide = false;\n          n.setExpanded(true);\n\n          _this12.setExpandedNodeList(n);\n\n          if (n.getParentNode()) {\n            return calc(n.getParentNode());\n          }\n        }\n      };\n\n      calc(node.getParentNode());\n    }\n  }]);\n\n  return NzTreeBaseService;\n}();\n\nNzTreeBaseService.Éµfac = function NzTreeBaseService_Factory(t) {\n  return new (t || NzTreeBaseService)();\n};\n\nNzTreeBaseService.Éµprov = /*@__PURE__*/Éµngcc0.ÉµÉµdefineInjectable({\n  token: NzTreeBaseService,\n  factory: NzTreeBaseService.Éµfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(NzTreeBaseService, [{\n    type: Injectable\n  }], function () {\n    return [];\n  }, null);\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nvar NzTreeHigherOrderServiceToken = new InjectionToken('NzTreeHigherOrder');\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nvar NzTreeBase = /*#__PURE__*/function () {\n  function NzTreeBase(nzTreeService) {\n    _classCallCheck(this, NzTreeBase);\n\n    this.nzTreeService = nzTreeService;\n  }\n  /**\n   * Coerces a value({@link any[]}) to a TreeNodes({@link NzTreeNode[]})\n   */\n\n\n  _createClass(NzTreeBase, [{\n    key: \"coerceTreeNodes\",\n    value: function coerceTreeNodes(value) {\n      var _this13 = this;\n\n      var nodes = [];\n\n      if (!this.nzTreeService.isArrayOfNzTreeNode(value)) {\n        // has not been new NzTreeNode\n        nodes = value.map(function (item) {\n          return new NzTreeNode(item, null, _this13.nzTreeService);\n        });\n      } else {\n        nodes = value.map(function (item) {\n          item.service = _this13.nzTreeService;\n          return item;\n        });\n      }\n\n      return nodes;\n    }\n    /**\n     * Get all nodes({@link NzTreeNode})\n     */\n\n  }, {\n    key: \"getTreeNodes\",\n    value: function getTreeNodes() {\n      return this.nzTreeService.rootNodes;\n    }\n    /**\n     * Get {@link NzTreeNode} with key\n     */\n\n  }, {\n    key: \"getTreeNodeByKey\",\n    value: function getTreeNodeByKey(key) {\n      // flat tree nodes\n      var nodes = [];\n\n      var getNode = function getNode(node) {\n        nodes.push(node);\n        node.getChildren().forEach(function (n) {\n          getNode(n);\n        });\n      };\n\n      this.getTreeNodes().forEach(function (n) {\n        getNode(n);\n      });\n      return nodes.find(function (n) {\n        return n.key === key;\n      }) || null;\n    }\n    /**\n     * Get checked nodes(merged)\n     */\n\n  }, {\n    key: \"getCheckedNodeList\",\n    value: function getCheckedNodeList() {\n      return this.nzTreeService.getCheckedNodeList();\n    }\n    /**\n     * Get selected nodes\n     */\n\n  }, {\n    key: \"getSelectedNodeList\",\n    value: function getSelectedNodeList() {\n      return this.nzTreeService.getSelectedNodeList();\n    }\n    /**\n     * Get half checked nodes\n     */\n\n  }, {\n    key: \"getHalfCheckedNodeList\",\n    value: function getHalfCheckedNodeList() {\n      return this.nzTreeService.getHalfCheckedNodeList();\n    }\n    /**\n     * Get expanded nodes\n     */\n\n  }, {\n    key: \"getExpandedNodeList\",\n    value: function getExpandedNodeList() {\n      return this.nzTreeService.getExpandedNodeList();\n    }\n    /**\n     * Get matched nodes(if nzSearchValue is not null)\n     */\n\n  }, {\n    key: \"getMatchedNodeList\",\n    value: function getMatchedNodeList() {\n      return this.nzTreeService.getMatchedNodeList();\n    }\n  }]);\n\n  return NzTreeBase;\n}();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NzTreeBase, NzTreeBaseService, NzTreeHigherOrderServiceToken, NzTreeNode, _flattenTreeData as flattenTreeData, getKey, getPosition, isCheckDisabled, isInArray }; //# sourceMappingURL=ng-zorro-antd-core-tree.js.map","map":{"version":3,"sources":["/Users/mac/WebstormProjects/github-page/node_modules/ng-zorro-antd/__ivy_ngcc__/fesm2015/ng-zorro-antd-core-tree.js"],"names":["Injectable","InjectionToken","BehaviorSubject","Éµngcc0","NzTreeNode","option","parent","service","_title","level","parentNode","_icon","_children","_isLeaf","_isChecked","_isSelectable","_isDisabled","_isDisableCheckbox","_isExpanded","_isHalfChecked","_isSelected","_isLoading","canHide","isMatched","origin","key","title","icon","isLeaf","checked","disabled","selectable","disableCheckbox","expanded","selected","children","forEach","nodeOptions","s","treeService","isCheckStrictly","push","value","update","afterValueChange","halfChecked","setChecked","conduct","isChecked","isHalfChecked","childPos","node","refreshLevel","n","getChildren","c","getParentNode","child","splice","e","map","v","isLoading","filter","setCheckedNodeList","setHalfCheckedNodeList","setExpandedNodeList","setNodeActive","afterRemove","flattenTreeData","rootNodes","getExpandedNodeList","component","markForCheck","isCheckDisabled","isDisabled","isDisableCheckbox","isInArray","needle","haystack","length","indexOf","getPosition","index","getKey","pos","undefined","treeNodeList","expandedKeys","expandedKeySet","Set","flattenList","dig","list","treeNode","mergedKey","isStart","isEnd","flattenNode","data","has","isExpanded","NzTreeBaseService","DRAG_SIDE_RANGE","DRAG_MIN_GAP","isMultiple","flattenNodes$","selectedNodeList","expandedNodeList","checkedNodeList","halfCheckedNodeList","matchedNodeList","nzNodes","next","item","selectedNode","conductNodeState","every","isSelected","setSelectedNodeList","getIndexOfArray","type","resultNodesList","isIgnore","findIndex","conductUp","conductDown","some","nodes","loopNode","refreshCheckState","refreshDragNode","resetNodeLevel","event","clientY","target","getBoundingClientRect","top","bottom","height","des","Math","max","targetNode","dragPos","targetParent","isSelectedRootNode","addChildren","tIndex","targetIndex","eventName","emitStructure","Object","assign","dragNode","getSelectedNode","selectedKeys","keys","getCheckedNodeList","checkedKeys","matchedKeys","getMatchedNodeList","checkStrictly","calc","setExpanded","isMulti","Éµfac","NzTreeBaseService_Factory","t","Éµprov","ÉµÉµdefineInjectable","token","factory","ngDevMode","ÉµsetClassMetadata","NzTreeHigherOrderServiceToken","NzTreeBase","nzTreeService","isArrayOfNzTreeNode","getNode","getTreeNodes","find","getSelectedNodeList","getHalfCheckedNodeList"],"mappings":"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","sourcesContent":["import { Injectable, InjectionToken } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nimport * as Éµngcc0 from '@angular/core';\nclass NzTreeNode {\n    /**\n     * Init nzTreeNode\n     * @param option: user's input\n     * @param parent\n     * @param service: base nzTreeService\n     */\n    constructor(option, parent = null, service = null) {\n        this._title = '';\n        this.level = 0;\n        // Parent Node\n        this.parentNode = null;\n        this._icon = '';\n        this._children = [];\n        this._isLeaf = false;\n        this._isChecked = false;\n        this._isSelectable = false;\n        this._isDisabled = false;\n        this._isDisableCheckbox = false;\n        this._isExpanded = false;\n        this._isHalfChecked = false;\n        this._isSelected = false;\n        this._isLoading = false;\n        this.canHide = false;\n        this.isMatched = false;\n        this.service = null;\n        if (option instanceof NzTreeNode) {\n            return option;\n        }\n        this.service = service || null;\n        this.origin = option;\n        this.key = option.key;\n        this.parentNode = parent;\n        this._title = option.title || '---';\n        this._icon = option.icon || '';\n        this._isLeaf = option.isLeaf || false;\n        this._children = [];\n        // option params\n        this._isChecked = option.checked || false;\n        this._isSelectable = option.disabled || option.selectable !== false;\n        this._isDisabled = option.disabled || false;\n        this._isDisableCheckbox = option.disableCheckbox || false;\n        this._isExpanded = option.isLeaf ? false : option.expanded || false;\n        this._isHalfChecked = false;\n        this._isSelected = (!option.disabled && option.selected) || false;\n        this._isLoading = false;\n        this.isMatched = false;\n        /**\n         * parent's checked status will affect children while initializing\n         */\n        if (parent) {\n            this.level = parent.level + 1;\n        }\n        else {\n            this.level = 0;\n        }\n        if (typeof option.children !== 'undefined' && option.children !== null) {\n            option.children.forEach(nodeOptions => {\n                const s = this.treeService;\n                if (s && !s.isCheckStrictly && option.checked && !option.disabled && !nodeOptions.disabled && !nodeOptions.disableCheckbox) {\n                    nodeOptions.checked = option.checked;\n                }\n                this._children.push(new NzTreeNode(nodeOptions, this));\n            });\n        }\n    }\n    get treeService() {\n        return this.service || (this.parentNode && this.parentNode.treeService);\n    }\n    /**\n     * auto generate\n     * get\n     * set\n     */\n    get title() {\n        return this._title;\n    }\n    set title(value) {\n        this._title = value;\n        this.update();\n    }\n    get icon() {\n        return this._icon;\n    }\n    set icon(value) {\n        this._icon = value;\n        this.update();\n    }\n    get children() {\n        return this._children;\n    }\n    set children(value) {\n        this._children = value;\n        this.update();\n    }\n    get isLeaf() {\n        return this._isLeaf;\n    }\n    set isLeaf(value) {\n        this._isLeaf = value;\n        this.update();\n    }\n    get isChecked() {\n        return this._isChecked;\n    }\n    set isChecked(value) {\n        this._isChecked = value;\n        this.origin.checked = value;\n        this.afterValueChange('isChecked');\n    }\n    get isHalfChecked() {\n        return this._isHalfChecked;\n    }\n    set isHalfChecked(value) {\n        this._isHalfChecked = value;\n        this.afterValueChange('isHalfChecked');\n    }\n    get isSelectable() {\n        return this._isSelectable;\n    }\n    set isSelectable(value) {\n        this._isSelectable = value;\n        this.update();\n    }\n    get isDisabled() {\n        return this._isDisabled;\n    }\n    set isDisabled(value) {\n        this._isDisabled = value;\n        this.update();\n    }\n    get isDisableCheckbox() {\n        return this._isDisableCheckbox;\n    }\n    set isDisableCheckbox(value) {\n        this._isDisableCheckbox = value;\n        this.update();\n    }\n    get isExpanded() {\n        return this._isExpanded;\n    }\n    set isExpanded(value) {\n        this._isExpanded = value;\n        this.origin.expanded = value;\n        this.afterValueChange('isExpanded');\n        this.afterValueChange('reRender');\n    }\n    get isSelected() {\n        return this._isSelected;\n    }\n    set isSelected(value) {\n        this._isSelected = value;\n        this.origin.selected = value;\n        this.afterValueChange('isSelected');\n    }\n    get isLoading() {\n        return this._isLoading;\n    }\n    set isLoading(value) {\n        this._isLoading = value;\n        this.update();\n    }\n    setSyncChecked(checked = false, halfChecked = false) {\n        this.setChecked(checked, halfChecked);\n        if (this.treeService && !this.treeService.isCheckStrictly) {\n            this.treeService.conduct(this);\n        }\n    }\n    setChecked(checked = false, halfChecked = false) {\n        this.origin.checked = checked;\n        this.isChecked = checked;\n        this.isHalfChecked = halfChecked;\n    }\n    setExpanded(value) {\n        this._isExpanded = value;\n        this.origin.expanded = value;\n        this.afterValueChange('isExpanded');\n    }\n    getParentNode() {\n        return this.parentNode;\n    }\n    getChildren() {\n        return this.children;\n    }\n    /**\n     * Support appending child nodes by position. Leaf node cannot be appended.\n     */\n    addChildren(children, childPos = -1) {\n        if (!this.isLeaf) {\n            children.forEach(node => {\n                const refreshLevel = (n) => {\n                    n.getChildren().forEach(c => {\n                        c.level = c.getParentNode().level + 1;\n                        // flush origin\n                        c.origin.level = c.level;\n                        refreshLevel(c);\n                    });\n                };\n                let child = node;\n                if (child instanceof NzTreeNode) {\n                    child.parentNode = this;\n                }\n                else {\n                    child = new NzTreeNode(node, this);\n                }\n                child.level = this.level + 1;\n                child.origin.level = child.level;\n                refreshLevel(child);\n                try {\n                    childPos === -1 ? this.children.push(child) : this.children.splice(childPos, 0, child);\n                    // flush origin\n                }\n                catch (e) { }\n            });\n            this.origin.children = this.getChildren().map(v => v.origin);\n            // remove loading state\n            this.isLoading = false;\n        }\n        this.afterValueChange('addChildren');\n        this.afterValueChange('reRender');\n    }\n    clearChildren() {\n        // refresh checked state\n        this.afterValueChange('clearChildren');\n        this.children = [];\n        this.origin.children = [];\n        this.afterValueChange('reRender');\n    }\n    remove() {\n        const parentNode = this.getParentNode();\n        if (parentNode) {\n            parentNode.children = parentNode.getChildren().filter(v => v.key !== this.key);\n            parentNode.origin.children = parentNode.origin.children.filter(v => v.key !== this.key);\n            this.afterValueChange('remove');\n            this.afterValueChange('reRender');\n        }\n    }\n    afterValueChange(key) {\n        if (this.treeService) {\n            switch (key) {\n                case 'isChecked':\n                    this.treeService.setCheckedNodeList(this);\n                    break;\n                case 'isHalfChecked':\n                    this.treeService.setHalfCheckedNodeList(this);\n                    break;\n                case 'isExpanded':\n                    this.treeService.setExpandedNodeList(this);\n                    break;\n                case 'isSelected':\n                    this.treeService.setNodeActive(this);\n                    break;\n                case 'clearChildren':\n                    this.treeService.afterRemove(this.getChildren());\n                    break;\n                case 'remove':\n                    this.treeService.afterRemove([this]);\n                    break;\n                case 'reRender':\n                    this.treeService.flattenTreeData(this.treeService.rootNodes, this.treeService.getExpandedNodeList().map(v => v.key));\n                    break;\n            }\n        }\n        this.update();\n    }\n    update() {\n        if (this.component) {\n            this.component.markForCheck();\n        }\n    }\n}\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nfunction isCheckDisabled(node) {\n    const { isDisabled, isDisableCheckbox } = node;\n    return !!(isDisabled || isDisableCheckbox);\n}\nfunction isInArray(needle, haystack) {\n    return haystack.length > 0 && haystack.indexOf(needle) > -1;\n}\nfunction getPosition(level, index) {\n    return `${level}-${index}`;\n}\nfunction getKey(key, pos) {\n    if (key !== null && key !== undefined) {\n        return key;\n    }\n    return pos;\n}\n/**\n * Flat nest tree data into flatten list. This is used for virtual list render.\n * @param treeNodeList Origin data node list\n * @param expandedKeys\n * need expanded keys, provides `true` means all expanded (used in `rc-tree-select`).\n */\nfunction flattenTreeData(treeNodeList = [], expandedKeys = []) {\n    const expandedKeySet = new Set(expandedKeys === true ? [] : expandedKeys);\n    const flattenList = [];\n    function dig(list, parent = null) {\n        return list.map((treeNode, index) => {\n            const pos = getPosition(parent ? parent.pos : '0', index);\n            const mergedKey = getKey(treeNode.key, pos);\n            treeNode.isStart = [...(parent ? parent.isStart : []), index === 0];\n            treeNode.isEnd = [...(parent ? parent.isEnd : []), index === list.length - 1];\n            // Add FlattenDataNode into list\n            // TODO: only need data here.\n            const flattenNode = {\n                parent,\n                pos,\n                children: [],\n                data: treeNode,\n                isStart: [...(parent ? parent.isStart : []), index === 0],\n                isEnd: [...(parent ? parent.isEnd : []), index === list.length - 1]\n            };\n            flattenList.push(flattenNode);\n            // Loop treeNode children\n            if (expandedKeys === true || expandedKeySet.has(mergedKey) || treeNode.isExpanded) {\n                flattenNode.children = dig(treeNode.children || [], flattenNode);\n            }\n            else {\n                flattenNode.children = [];\n            }\n            return flattenNode;\n        });\n    }\n    dig(treeNodeList);\n    return flattenList;\n}\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzTreeBaseService {\n    constructor() {\n        this.DRAG_SIDE_RANGE = 0.25;\n        this.DRAG_MIN_GAP = 2;\n        this.isCheckStrictly = false;\n        this.isMultiple = false;\n        this.rootNodes = [];\n        this.flattenNodes$ = new BehaviorSubject([]);\n        this.selectedNodeList = [];\n        this.expandedNodeList = [];\n        this.checkedNodeList = [];\n        this.halfCheckedNodeList = [];\n        this.matchedNodeList = [];\n    }\n    /**\n     * reset tree nodes will clear default node list\n     */\n    initTree(nzNodes) {\n        this.rootNodes = nzNodes;\n        this.expandedNodeList = [];\n        this.selectedNodeList = [];\n        this.halfCheckedNodeList = [];\n        this.checkedNodeList = [];\n        this.matchedNodeList = [];\n    }\n    flattenTreeData(nzNodes, expandedKeys = []) {\n        this.flattenNodes$.next(flattenTreeData(nzNodes, expandedKeys).map(item => item.data));\n    }\n    getSelectedNode() {\n        return this.selectedNode;\n    }\n    /**\n     * get some list\n     */\n    getSelectedNodeList() {\n        return this.conductNodeState('select');\n    }\n    /**\n     * return checked nodes\n     */\n    getCheckedNodeList() {\n        return this.conductNodeState('check');\n    }\n    getHalfCheckedNodeList() {\n        return this.conductNodeState('halfCheck');\n    }\n    /**\n     * return expanded nodes\n     */\n    getExpandedNodeList() {\n        return this.conductNodeState('expand');\n    }\n    /**\n     * return search matched nodes\n     */\n    getMatchedNodeList() {\n        return this.conductNodeState('match');\n    }\n    isArrayOfNzTreeNode(value) {\n        return value.every(item => item instanceof NzTreeNode);\n    }\n    /**\n     * set drag node\n     */\n    setSelectedNode(node) {\n        this.selectedNode = node;\n    }\n    /**\n     * set node selected status\n     */\n    setNodeActive(node) {\n        if (!this.isMultiple && node.isSelected) {\n            this.selectedNodeList.forEach(n => {\n                if (node.key !== n.key) {\n                    // reset other nodes\n                    n.isSelected = false;\n                }\n            });\n            // single mode: remove pre node\n            this.selectedNodeList = [];\n        }\n        this.setSelectedNodeList(node, this.isMultiple);\n    }\n    /**\n     * add or remove node to selectedNodeList\n     */\n    setSelectedNodeList(node, isMultiple = false) {\n        const index = this.getIndexOfArray(this.selectedNodeList, node.key);\n        if (isMultiple) {\n            if (node.isSelected && index === -1) {\n                this.selectedNodeList.push(node);\n            }\n        }\n        else {\n            if (node.isSelected && index === -1) {\n                this.selectedNodeList = [node];\n            }\n        }\n        if (!node.isSelected) {\n            this.selectedNodeList = this.selectedNodeList.filter(n => n.key !== node.key);\n        }\n    }\n    /**\n     * merge checked nodes\n     */\n    setHalfCheckedNodeList(node) {\n        const index = this.getIndexOfArray(this.halfCheckedNodeList, node.key);\n        if (node.isHalfChecked && index === -1) {\n            this.halfCheckedNodeList.push(node);\n        }\n        else if (!node.isHalfChecked && index > -1) {\n            this.halfCheckedNodeList = this.halfCheckedNodeList.filter(n => node.key !== n.key);\n        }\n    }\n    setCheckedNodeList(node) {\n        const index = this.getIndexOfArray(this.checkedNodeList, node.key);\n        if (node.isChecked && index === -1) {\n            this.checkedNodeList.push(node);\n        }\n        else if (!node.isChecked && index > -1) {\n            this.checkedNodeList = this.checkedNodeList.filter(n => node.key !== n.key);\n        }\n    }\n    /**\n     * conduct checked/selected/expanded keys\n     */\n    conductNodeState(type = 'check') {\n        let resultNodesList = [];\n        switch (type) {\n            case 'select':\n                resultNodesList = this.selectedNodeList;\n                break;\n            case 'expand':\n                resultNodesList = this.expandedNodeList;\n                break;\n            case 'match':\n                resultNodesList = this.matchedNodeList;\n                break;\n            case 'check':\n                resultNodesList = this.checkedNodeList;\n                const isIgnore = (node) => {\n                    const parentNode = node.getParentNode();\n                    if (parentNode) {\n                        if (this.checkedNodeList.findIndex(n => n.key === parentNode.key) > -1) {\n                            return true;\n                        }\n                        else {\n                            return isIgnore(parentNode);\n                        }\n                    }\n                    return false;\n                };\n                // merge checked\n                if (!this.isCheckStrictly) {\n                    resultNodesList = this.checkedNodeList.filter(n => !isIgnore(n));\n                }\n                break;\n            case 'halfCheck':\n                if (!this.isCheckStrictly) {\n                    resultNodesList = this.halfCheckedNodeList;\n                }\n                break;\n        }\n        return resultNodesList;\n    }\n    /**\n     * set expanded nodes\n     */\n    setExpandedNodeList(node) {\n        if (node.isLeaf) {\n            return;\n        }\n        const index = this.getIndexOfArray(this.expandedNodeList, node.key);\n        if (node.isExpanded && index === -1) {\n            this.expandedNodeList.push(node);\n        }\n        else if (!node.isExpanded && index > -1) {\n            this.expandedNodeList.splice(index, 1);\n        }\n    }\n    setMatchedNodeList(node) {\n        const index = this.getIndexOfArray(this.matchedNodeList, node.key);\n        if (node.isMatched && index === -1) {\n            this.matchedNodeList.push(node);\n        }\n        else if (!node.isMatched && index > -1) {\n            this.matchedNodeList.splice(index, 1);\n        }\n    }\n    /**\n     * check state\n     * @param isCheckStrictly\n     */\n    refreshCheckState(isCheckStrictly = false) {\n        if (isCheckStrictly) {\n            return;\n        }\n        this.checkedNodeList.forEach(node => {\n            this.conduct(node, isCheckStrictly);\n        });\n    }\n    // reset other node checked state based current node\n    conduct(node, isCheckStrictly = false) {\n        const isChecked = node.isChecked;\n        if (node && !isCheckStrictly) {\n            this.conductUp(node);\n            this.conductDown(node, isChecked);\n        }\n    }\n    /**\n     * 1ãchildren half checked\n     * 2ãchildren all checked, parent checked\n     * 3ãno children checked\n     */\n    conductUp(node) {\n        const parentNode = node.getParentNode();\n        if (parentNode) {\n            if (!isCheckDisabled(parentNode)) {\n                if (parentNode.children.every(child => isCheckDisabled(child) || (!child.isHalfChecked && child.isChecked))) {\n                    parentNode.isChecked = true;\n                    parentNode.isHalfChecked = false;\n                }\n                else if (parentNode.children.some(child => child.isHalfChecked || child.isChecked)) {\n                    parentNode.isChecked = false;\n                    parentNode.isHalfChecked = true;\n                }\n                else {\n                    parentNode.isChecked = false;\n                    parentNode.isHalfChecked = false;\n                }\n            }\n            this.setCheckedNodeList(parentNode);\n            this.setHalfCheckedNodeList(parentNode);\n            this.conductUp(parentNode);\n        }\n    }\n    /**\n     * reset child check state\n     */\n    conductDown(node, value) {\n        if (!isCheckDisabled(node)) {\n            node.isChecked = value;\n            node.isHalfChecked = false;\n            this.setCheckedNodeList(node);\n            this.setHalfCheckedNodeList(node);\n            node.children.forEach(n => {\n                this.conductDown(n, value);\n            });\n        }\n    }\n    /**\n     * flush after delete node\n     */\n    afterRemove(nodes) {\n        // to reset selectedNodeList & expandedNodeList\n        const loopNode = (node) => {\n            // remove selected node\n            this.selectedNodeList = this.selectedNodeList.filter(n => n.key !== node.key);\n            // remove expanded node\n            this.expandedNodeList = this.expandedNodeList.filter(n => n.key !== node.key);\n            // remove checked node\n            this.checkedNodeList = this.checkedNodeList.filter(n => n.key !== node.key);\n            if (node.children) {\n                node.children.forEach(child => {\n                    loopNode(child);\n                });\n            }\n        };\n        nodes.forEach(n => {\n            loopNode(n);\n        });\n        this.refreshCheckState(this.isCheckStrictly);\n    }\n    /**\n     * drag event\n     */\n    refreshDragNode(node) {\n        if (node.children.length === 0) {\n            // until root\n            this.conductUp(node);\n        }\n        else {\n            node.children.forEach(child => {\n                this.refreshDragNode(child);\n            });\n        }\n    }\n    // reset node level\n    resetNodeLevel(node) {\n        const parentNode = node.getParentNode();\n        if (parentNode) {\n            node.level = parentNode.level + 1;\n        }\n        else {\n            node.level = 0;\n        }\n        for (const child of node.children) {\n            this.resetNodeLevel(child);\n        }\n    }\n    calcDropPosition(event) {\n        const { clientY } = event;\n        // to fix firefox undefined\n        const { top, bottom, height } = event.target.getBoundingClientRect();\n        const des = Math.max(height * this.DRAG_SIDE_RANGE, this.DRAG_MIN_GAP);\n        if (clientY <= top + des) {\n            return -1;\n        }\n        else if (clientY >= bottom - des) {\n            return 1;\n        }\n        return 0;\n    }\n    /**\n     * drop\n     * 0: inner -1: pre 1: next\n     */\n    dropAndApply(targetNode, dragPos = -1) {\n        if (!targetNode || dragPos > 1) {\n            return;\n        }\n        const treeService = targetNode.treeService;\n        const targetParent = targetNode.getParentNode();\n        const isSelectedRootNode = this.selectedNode.getParentNode();\n        // remove the dragNode\n        if (isSelectedRootNode) {\n            isSelectedRootNode.children = isSelectedRootNode.children.filter(n => n.key !== this.selectedNode.key);\n        }\n        else {\n            this.rootNodes = this.rootNodes.filter(n => n.key !== this.selectedNode.key);\n        }\n        switch (dragPos) {\n            case 0:\n                targetNode.addChildren([this.selectedNode]);\n                this.resetNodeLevel(targetNode);\n                break;\n            case -1:\n            case 1:\n                const tIndex = dragPos === 1 ? 1 : 0;\n                if (targetParent) {\n                    targetParent.addChildren([this.selectedNode], targetParent.children.indexOf(targetNode) + tIndex);\n                    const parentNode = this.selectedNode.getParentNode();\n                    if (parentNode) {\n                        this.resetNodeLevel(parentNode);\n                    }\n                }\n                else {\n                    const targetIndex = this.rootNodes.indexOf(targetNode) + tIndex;\n                    // Insert root node.\n                    this.rootNodes.splice(targetIndex, 0, this.selectedNode);\n                    this.rootNodes[targetIndex].parentNode = null;\n                    this.resetNodeLevel(this.rootNodes[targetIndex]);\n                }\n                break;\n        }\n        // flush all nodes\n        this.rootNodes.forEach(child => {\n            if (!child.treeService) {\n                child.service = treeService;\n            }\n            this.refreshDragNode(child);\n        });\n    }\n    /**\n     * emit Structure\n     * eventName\n     * node\n     * event: MouseEvent / DragEvent\n     * dragNode\n     */\n    formatEvent(eventName, node, event) {\n        const emitStructure = {\n            eventName: eventName,\n            node: node,\n            event: event\n        };\n        switch (eventName) {\n            case 'dragstart':\n            case 'dragenter':\n            case 'dragover':\n            case 'dragleave':\n            case 'drop':\n            case 'dragend':\n                Object.assign(emitStructure, { dragNode: this.getSelectedNode() });\n                break;\n            case 'click':\n            case 'dblclick':\n                Object.assign(emitStructure, { selectedKeys: this.selectedNodeList });\n                Object.assign(emitStructure, { nodes: this.selectedNodeList });\n                Object.assign(emitStructure, { keys: this.selectedNodeList.map(n => n.key) });\n                break;\n            case 'check':\n                const checkedNodeList = this.getCheckedNodeList();\n                Object.assign(emitStructure, { checkedKeys: checkedNodeList });\n                Object.assign(emitStructure, { nodes: checkedNodeList });\n                Object.assign(emitStructure, { keys: checkedNodeList.map(n => n.key) });\n                break;\n            case 'search':\n                Object.assign(emitStructure, { matchedKeys: this.getMatchedNodeList() });\n                Object.assign(emitStructure, { nodes: this.getMatchedNodeList() });\n                Object.assign(emitStructure, { keys: this.getMatchedNodeList().map(n => n.key) });\n                break;\n            case 'expand':\n                Object.assign(emitStructure, { nodes: this.expandedNodeList });\n                Object.assign(emitStructure, { keys: this.expandedNodeList.map(n => n.key) });\n                break;\n        }\n        return emitStructure;\n    }\n    /**\n     * New functions for flatten nodes\n     */\n    getIndexOfArray(list, key) {\n        return list.findIndex(v => v.key === key);\n    }\n    /**\n     * Render by nzCheckedKeys\n     * When keys equals null, just render with checkStrictly\n     * @param keys\n     * @param checkStrictly\n     */\n    conductCheck(keys, checkStrictly) {\n        this.checkedNodeList = [];\n        this.halfCheckedNodeList = [];\n        const calc = (nodes) => {\n            nodes.forEach(node => {\n                if (keys === null) {\n                    // render tree if no default checked keys found\n                    node.isChecked = !!node.origin.checked;\n                }\n                else {\n                    if (isInArray(node.key, keys || [])) {\n                        node.isChecked = true;\n                        node.isHalfChecked = false;\n                    }\n                    else {\n                        node.isChecked = false;\n                        node.isHalfChecked = false;\n                    }\n                }\n                if (node.children.length > 0) {\n                    calc(node.children);\n                }\n            });\n        };\n        calc(this.rootNodes);\n        this.refreshCheckState(checkStrictly);\n    }\n    conductExpandedKeys(keys = []) {\n        const expandedKeySet = new Set(keys === true ? [] : keys);\n        this.expandedNodeList = [];\n        const calc = (nodes) => {\n            nodes.forEach(node => {\n                node.setExpanded(keys === true || expandedKeySet.has(node.key) || node.isExpanded === true);\n                if (node.isExpanded) {\n                    this.setExpandedNodeList(node);\n                }\n                if (node.children.length > 0) {\n                    calc(node.children);\n                }\n            });\n        };\n        calc(this.rootNodes);\n    }\n    conductSelectedKeys(keys, isMulti) {\n        this.selectedNodeList.forEach(node => (node.isSelected = false));\n        this.selectedNodeList = [];\n        const calc = (nodes) => {\n            return nodes.every(node => {\n                if (isInArray(node.key, keys)) {\n                    node.isSelected = true;\n                    this.setSelectedNodeList(node);\n                    if (!isMulti) {\n                        // if not support multi select\n                        return false;\n                    }\n                }\n                else {\n                    node.isSelected = false;\n                }\n                if (node.children.length > 0) {\n                    // Recursion\n                    return calc(node.children);\n                }\n                return true;\n            });\n        };\n        calc(this.rootNodes);\n    }\n    /**\n     * Expand parent nodes by child node\n     * @param node\n     */\n    expandNodeAllParentBySearch(node) {\n        const calc = (n) => {\n            if (n) {\n                n.canHide = false;\n                n.setExpanded(true);\n                this.setExpandedNodeList(n);\n                if (n.getParentNode()) {\n                    return calc(n.getParentNode());\n                }\n            }\n        };\n        calc(node.getParentNode());\n    }\n}\nNzTreeBaseService.Éµfac = function NzTreeBaseService_Factory(t) { return new (t || NzTreeBaseService)(); };\nNzTreeBaseService.Éµprov = /*@__PURE__*/ Éµngcc0.ÉµÉµdefineInjectable({ token: NzTreeBaseService, factory: NzTreeBaseService.Éµfac });\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(NzTreeBaseService, [{\n        type: Injectable\n    }], function () { return []; }, null); })();\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nconst NzTreeHigherOrderServiceToken = new InjectionToken('NzTreeHigherOrder');\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzTreeBase {\n    constructor(nzTreeService) {\n        this.nzTreeService = nzTreeService;\n    }\n    /**\n     * Coerces a value({@link any[]}) to a TreeNodes({@link NzTreeNode[]})\n     */\n    coerceTreeNodes(value) {\n        let nodes = [];\n        if (!this.nzTreeService.isArrayOfNzTreeNode(value)) {\n            // has not been new NzTreeNode\n            nodes = value.map(item => new NzTreeNode(item, null, this.nzTreeService));\n        }\n        else {\n            nodes = value.map((item) => {\n                item.service = this.nzTreeService;\n                return item;\n            });\n        }\n        return nodes;\n    }\n    /**\n     * Get all nodes({@link NzTreeNode})\n     */\n    getTreeNodes() {\n        return this.nzTreeService.rootNodes;\n    }\n    /**\n     * Get {@link NzTreeNode} with key\n     */\n    getTreeNodeByKey(key) {\n        // flat tree nodes\n        const nodes = [];\n        const getNode = (node) => {\n            nodes.push(node);\n            node.getChildren().forEach(n => {\n                getNode(n);\n            });\n        };\n        this.getTreeNodes().forEach(n => {\n            getNode(n);\n        });\n        return nodes.find(n => n.key === key) || null;\n    }\n    /**\n     * Get checked nodes(merged)\n     */\n    getCheckedNodeList() {\n        return this.nzTreeService.getCheckedNodeList();\n    }\n    /**\n     * Get selected nodes\n     */\n    getSelectedNodeList() {\n        return this.nzTreeService.getSelectedNodeList();\n    }\n    /**\n     * Get half checked nodes\n     */\n    getHalfCheckedNodeList() {\n        return this.nzTreeService.getHalfCheckedNodeList();\n    }\n    /**\n     * Get expanded nodes\n     */\n    getExpandedNodeList() {\n        return this.nzTreeService.getExpandedNodeList();\n    }\n    /**\n     * Get matched nodes(if nzSearchValue is not null)\n     */\n    getMatchedNodeList() {\n        return this.nzTreeService.getMatchedNodeList();\n    }\n}\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NzTreeBase, NzTreeBaseService, NzTreeHigherOrderServiceToken, NzTreeNode, flattenTreeData, getKey, getPosition, isCheckDisabled, isInArray };\n\n//# sourceMappingURL=ng-zorro-antd-core-tree.js.map"]},"metadata":{},"sourceType":"module"}